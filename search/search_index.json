{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Terraform Test Framework \u00b6 Unified Test Framework to test Terraform codes and Terraform-provisioned infrastructures. The first release, v0.1.0 (Shadowman) is now available. Documentation: https://tf2project.io Source Code: https://github.com/tf2project/tf2project TF2 is a unified test framework to test Terraform codes and Terraform-provisioned infrastructures. With TF2 , you can implement PaC( Policy as Code ), Compliance tests, e2e( End to End ) tests, and all other tests just in a unified framework. History \u00b6 This idea crossed my mind when I was managing a big DevOps team that was working on various Terraform codes, and they were developing many Terraform codes and modules for several projects together. As a manager and a person who was responsible for accepting merge requests, I had to review their codes, and in some cases, I had to test them. Big team! Big problem! Reviewing more than 500 lines of codes a day and testing them had turned into my nightmare. Some problems that I faced with them are: Implementing Policy-as-Code while we have not got TFC / TFE to use Sentinel. Implementing e2e tests to test real infrastructures after deploying Terraform codes. Implementing standard rules for developing Terraform codes. The thing is, it doesn't matter how many engineers you have in your team. If you want to implement policies, test your codes, and your infrastructures, and deliver better and more reliable Terraform codes, you should use Terraform Test Framework. Philosophy \u00b6 Implement a unified framework to implement all Terraform test needs. Implement a standard path to integrate Terraform tests into CI/CD pipelines. Implement a DevOps-friendly framework for all DevOps engineers. Features \u00b6 TF2 is under development, and many features will be added soon. Now the following features are implemented and can be used in production: Implementing Compliance tests and Policy as Code (Before deployment) Implementing End to End tests (After deployment) Integrations \u00b6 TF2 is fully compatible and can be integrated with: Terraform Open-source, Terraform Cloud, Terraform Enterprise CI/CD systems like Jenkins CI, Gitlab CI, GitHub Actions Comparison \u00b6 TF2 vs. Sentinel \u00b6 Terraform Cloud and Terraform Enterprise come with a Policy-as-Code tool called Sentinel . Sentinel uses its programming language, and you should learn a new language to implement your tests. Of course, just policy as code. Moreover, none of them provides a solution to implement e2e(End to End) tests. With TF2 , you can write both with the most DevOps engineers-friendly programming language, Python. TF2 is also available for Terraform open-source users. Service TF2 TFO TFC TFE Policy-as-Code End-to-End Tests TF2 vs. Terratest \u00b6 Terratest is a good tool by Gruntwork which allows you to implement e2e tests, but it doesn't provide any Policy-as-Code solution. To write your tests with Terratest, you should know how to write Go applications. TF2 makes the test world for DevOps engineers really easy. You can write your PaC and e2e tests in Python, DevOps engineers' lovely language. Service TF2 Terratest Policy-as-Code End-to-End Tests TF2 vs. Terraform-compliance \u00b6 It's a cool tool to implement Policy as Code in a BDD(Behaviour Driven Development) language. It's really a lovely tool, but it doesn't support e2e tests, and it's not expandable like TF2 . TF2 opens your hands to implement everything you need. Service TF2 terraform-compliance Policy-as-Code End-to-End Tests Requirements \u00b6 The TF2 core doesn't have any external or third-party requirements, and we will keep this approach as the main development policy to reduce the attack surface. This policy is created because you run the TF2 in your critical environments, CI/CD systems, and cloud/on-premises infrastructures, and we want to keep you completely secure. The TF2 core is just using standard and official Python libraries. Installation \u00b6 pip install tf2project License \u00b6 This project is licensed under the terms of the Apache 2.0 license.","title":"Home"},{"location":"index.html#terraform-test-framework","text":"Unified Test Framework to test Terraform codes and Terraform-provisioned infrastructures. The first release, v0.1.0 (Shadowman) is now available. Documentation: https://tf2project.io Source Code: https://github.com/tf2project/tf2project TF2 is a unified test framework to test Terraform codes and Terraform-provisioned infrastructures. With TF2 , you can implement PaC( Policy as Code ), Compliance tests, e2e( End to End ) tests, and all other tests just in a unified framework.","title":"Terraform Test Framework"},{"location":"index.html#history","text":"This idea crossed my mind when I was managing a big DevOps team that was working on various Terraform codes, and they were developing many Terraform codes and modules for several projects together. As a manager and a person who was responsible for accepting merge requests, I had to review their codes, and in some cases, I had to test them. Big team! Big problem! Reviewing more than 500 lines of codes a day and testing them had turned into my nightmare. Some problems that I faced with them are: Implementing Policy-as-Code while we have not got TFC / TFE to use Sentinel. Implementing e2e tests to test real infrastructures after deploying Terraform codes. Implementing standard rules for developing Terraform codes. The thing is, it doesn't matter how many engineers you have in your team. If you want to implement policies, test your codes, and your infrastructures, and deliver better and more reliable Terraform codes, you should use Terraform Test Framework.","title":"History"},{"location":"index.html#philosophy","text":"Implement a unified framework to implement all Terraform test needs. Implement a standard path to integrate Terraform tests into CI/CD pipelines. Implement a DevOps-friendly framework for all DevOps engineers.","title":"Philosophy"},{"location":"index.html#features","text":"TF2 is under development, and many features will be added soon. Now the following features are implemented and can be used in production: Implementing Compliance tests and Policy as Code (Before deployment) Implementing End to End tests (After deployment)","title":"Features"},{"location":"index.html#integrations","text":"TF2 is fully compatible and can be integrated with: Terraform Open-source, Terraform Cloud, Terraform Enterprise CI/CD systems like Jenkins CI, Gitlab CI, GitHub Actions","title":"Integrations"},{"location":"index.html#comparison","text":"","title":"Comparison"},{"location":"index.html#tf2-vs-sentinel","text":"Terraform Cloud and Terraform Enterprise come with a Policy-as-Code tool called Sentinel . Sentinel uses its programming language, and you should learn a new language to implement your tests. Of course, just policy as code. Moreover, none of them provides a solution to implement e2e(End to End) tests. With TF2 , you can write both with the most DevOps engineers-friendly programming language, Python. TF2 is also available for Terraform open-source users. Service TF2 TFO TFC TFE Policy-as-Code End-to-End Tests","title":"TF2 vs. Sentinel"},{"location":"index.html#tf2-vs-terratest","text":"Terratest is a good tool by Gruntwork which allows you to implement e2e tests, but it doesn't provide any Policy-as-Code solution. To write your tests with Terratest, you should know how to write Go applications. TF2 makes the test world for DevOps engineers really easy. You can write your PaC and e2e tests in Python, DevOps engineers' lovely language. Service TF2 Terratest Policy-as-Code End-to-End Tests","title":"TF2 vs. Terratest"},{"location":"index.html#tf2-vs-terraform-compliance","text":"It's a cool tool to implement Policy as Code in a BDD(Behaviour Driven Development) language. It's really a lovely tool, but it doesn't support e2e tests, and it's not expandable like TF2 . TF2 opens your hands to implement everything you need. Service TF2 terraform-compliance Policy-as-Code End-to-End Tests","title":"TF2 vs. Terraform-compliance"},{"location":"index.html#requirements","text":"The TF2 core doesn't have any external or third-party requirements, and we will keep this approach as the main development policy to reduce the attack surface. This policy is created because you run the TF2 in your critical environments, CI/CD systems, and cloud/on-premises infrastructures, and we want to keep you completely secure. The TF2 core is just using standard and official Python libraries.","title":"Requirements"},{"location":"index.html#installation","text":"pip install tf2project","title":"Installation"},{"location":"index.html#license","text":"This project is licensed under the terms of the Apache 2.0 license.","title":"License"},{"location":"about.html","text":"About \u00b6 TF2 is a new tool in the Terraform testing market, and many features will be added soon. How to contribute guide and code of conduct will be published soon to make you able to contribute to the project. If you have any questions, ping me on LinkedIn. I'm the creator and maintainer of the Terraform Test Framework.","title":"About"},{"location":"about.html#about","text":"TF2 is a new tool in the Terraform testing market, and many features will be added soon. How to contribute guide and code of conduct will be published soon to make you able to contribute to the project. If you have any questions, ping me on LinkedIn. I'm the creator and maintainer of the Terraform Test Framework.","title":"About"},{"location":"docs/getting-started/end-to-end-tests.html","text":"Getting Started: End to End Tests \u00b6 The purpose of End to End \" e2e \" Tests is to make sure the behaviour of the software, infrastructure, etc., is what we expect. With TF2, you can implement e2e tests to test your Terraform codes after they are deployed to real infrastructures. In the case of Terraform: DevOps engineers are responsible for writing Terraform codes as well as writing e2e tests and integrating them into CI / CD pipelines. From now on, TF2 is always there for you to test your Terraform-provisioned infrastructures. Not only infrastructures but also everything you managed and deployed by the Terraform, as well as all Terraform data resources. Moreover, TF2 can be integrated into your CD pipelines, and after deploying the new Terraform codes, you can run the tests to test the infrastructure's behaviour in the real world. If something goes wrong or is unusual, you can detect it and rollback the system to the previous working state. With this approach, you can deliver better and more reliable infrastructures and reduce your unexpected situations and downtimes. I'm compatible TF2 is fully compatible with Jenkins CI , Gitlab CI , GitHub Actions and Azure Pipelines. Your first End to End test \u00b6 Consider the following Terraform code. It's a standard Terraform code to deploy a Docker container. To test this scenario, you should install Docker on your local machine. main.tf terraform { required_providers { docker = { source = \"kreuzwerker/docker\" version = \">= 2.16\" } } } provider \"docker\" { host = \"unix:///var/run/docker.sock\" } resource \"docker_container\" \"nginx\" { name = \"nginx\" image = \"nginx:1\" restart = \"unless-stopped\" } output \"nginx_address\" { value = \"http://localhost\" } Now deploy the Docker container by running the following commands: terraform init terraform apply Do you want to perform these actions? yes docker_container.nginx: Creating... Apply complete! Resources: 1 added, 0 destroyed. Outputs: nginx_address = \"http://localhost\" Our desired state about the deployed container: The container should be run without any problem. The container can be accessed by the nginx_address output. To automate testing the container status and accessibility, write the following code: tests.py from tf2 import Tf2 , LocalCommandExecutor tf2 = Tf2 () @tf2 . test ( \"resources.docker_container.nginx\" ) def test_nginx_status ( self ): assert LocalCommandExecutor ( f \"docker container inspect { self . values . name } -f ' {{{{ .State.Status }}}} '\" ) . result . stdout . strip () == \"running\" @tf2 . test ( \"resources.docker_container.nginx\" ) def test_nginx_public_access ( self ): assert LocalCommandExecutor ( f \"curl -s { tf2 . outputs . nginx_address . value } \" ) . result . rc == 0 tf2 . run () Now, run the test script and see the result. Before running tests, make sure you have installed the tf2project package. Run pip install tf2project to install it on your machine. Run your TF2 tests with the following command: python tests.py As you can see, the test has failed because the container cannot be accessed through the network as we expected. Actually, this problem happened because of resource misconfiguration, and such problems are out of Terraform's scope, and it cannot detect them. Now update the Terraform code to the following code, apply it, and run the tests again. main.tf terraform { required_providers { docker = { source = \"kreuzwerker/docker\" version = \">= 2.16\" } } } provider \"docker\" { host = \"unix:///var/run/docker.sock\" } resource \"docker_container\" \"nginx\" { name = \"nginx\" image = \"nginx:1\" restart = \"unless-stopped\" ports { internal = 80 external = 80 } } output \"nginx_address\" { value = \"http://localhost\" } Run the following commands to apply and test: terraform apply Do you want to perform these actions? yes docker_container.nginx: Destroying... docker_container.nginx: Destruction complete after 0s docker_container.nginx: Creating... Apply complete! Resources: 1 added, 1 destroyed. Outputs: nginx_address = \"http://localhost\" python tests.py Result If tests pass, the test script will be exited with return code 0 , and passed will be written to the .tf2result file, and if they fail, the test script will be exited with return code 1 , and failed will be written to the .tf2result file. That's it. You wrote your first End to End test with Terraform Test Framework. Now, you can deliver better and more reliable Terraform-provisioned infrastructures.","title":"End to End Tests"},{"location":"docs/getting-started/end-to-end-tests.html#getting-started-end-to-end-tests","text":"The purpose of End to End \" e2e \" Tests is to make sure the behaviour of the software, infrastructure, etc., is what we expect. With TF2, you can implement e2e tests to test your Terraform codes after they are deployed to real infrastructures. In the case of Terraform: DevOps engineers are responsible for writing Terraform codes as well as writing e2e tests and integrating them into CI / CD pipelines. From now on, TF2 is always there for you to test your Terraform-provisioned infrastructures. Not only infrastructures but also everything you managed and deployed by the Terraform, as well as all Terraform data resources. Moreover, TF2 can be integrated into your CD pipelines, and after deploying the new Terraform codes, you can run the tests to test the infrastructure's behaviour in the real world. If something goes wrong or is unusual, you can detect it and rollback the system to the previous working state. With this approach, you can deliver better and more reliable infrastructures and reduce your unexpected situations and downtimes. I'm compatible TF2 is fully compatible with Jenkins CI , Gitlab CI , GitHub Actions and Azure Pipelines.","title":"Getting Started: End to End Tests"},{"location":"docs/getting-started/end-to-end-tests.html#your-first-end-to-end-test","text":"Consider the following Terraform code. It's a standard Terraform code to deploy a Docker container. To test this scenario, you should install Docker on your local machine. main.tf terraform { required_providers { docker = { source = \"kreuzwerker/docker\" version = \">= 2.16\" } } } provider \"docker\" { host = \"unix:///var/run/docker.sock\" } resource \"docker_container\" \"nginx\" { name = \"nginx\" image = \"nginx:1\" restart = \"unless-stopped\" } output \"nginx_address\" { value = \"http://localhost\" } Now deploy the Docker container by running the following commands: terraform init terraform apply Do you want to perform these actions? yes docker_container.nginx: Creating... Apply complete! Resources: 1 added, 0 destroyed. Outputs: nginx_address = \"http://localhost\" Our desired state about the deployed container: The container should be run without any problem. The container can be accessed by the nginx_address output. To automate testing the container status and accessibility, write the following code: tests.py from tf2 import Tf2 , LocalCommandExecutor tf2 = Tf2 () @tf2 . test ( \"resources.docker_container.nginx\" ) def test_nginx_status ( self ): assert LocalCommandExecutor ( f \"docker container inspect { self . values . name } -f ' {{{{ .State.Status }}}} '\" ) . result . stdout . strip () == \"running\" @tf2 . test ( \"resources.docker_container.nginx\" ) def test_nginx_public_access ( self ): assert LocalCommandExecutor ( f \"curl -s { tf2 . outputs . nginx_address . value } \" ) . result . rc == 0 tf2 . run () Now, run the test script and see the result. Before running tests, make sure you have installed the tf2project package. Run pip install tf2project to install it on your machine. Run your TF2 tests with the following command: python tests.py As you can see, the test has failed because the container cannot be accessed through the network as we expected. Actually, this problem happened because of resource misconfiguration, and such problems are out of Terraform's scope, and it cannot detect them. Now update the Terraform code to the following code, apply it, and run the tests again. main.tf terraform { required_providers { docker = { source = \"kreuzwerker/docker\" version = \">= 2.16\" } } } provider \"docker\" { host = \"unix:///var/run/docker.sock\" } resource \"docker_container\" \"nginx\" { name = \"nginx\" image = \"nginx:1\" restart = \"unless-stopped\" ports { internal = 80 external = 80 } } output \"nginx_address\" { value = \"http://localhost\" } Run the following commands to apply and test: terraform apply Do you want to perform these actions? yes docker_container.nginx: Destroying... docker_container.nginx: Destruction complete after 0s docker_container.nginx: Creating... Apply complete! Resources: 1 added, 1 destroyed. Outputs: nginx_address = \"http://localhost\" python tests.py Result If tests pass, the test script will be exited with return code 0 , and passed will be written to the .tf2result file, and if they fail, the test script will be exited with return code 1 , and failed will be written to the .tf2result file. That's it. You wrote your first End to End test with Terraform Test Framework. Now, you can deliver better and more reliable Terraform-provisioned infrastructures.","title":"Your first End to End test"},{"location":"docs/getting-started/policy-as-code.html","text":"Getting Started: Policy as Code \u00b6 Policy as Code, PaC , is a set of rules and conditions which is written as a code. With Policy-as-Code, you can implement compliance tests and enforce developers to write their codes in a standard way which fits your company rules. In the case of Terraform: DevOps engineers write Terraform codes. You write Policy-as-Code codes. When DevOps engineers make any changes in repositories containing Terraform codes, the PaC codes will be run as part of CI pipelines. If they have not followed PaC rules, the pipeline fails, and changes are not accepted to be merged into the main branch. I'm compatible TF2 is fully compatible with Jenkins CI , Gitlab CI , GitHub Actions and Azure Pipelines. Your first Policy as Code \u00b6 Consider the following Terraform code. This is a standard Terraform code which is written by DevOps engineers to deploy a Deployment Resource in a Kubernetes environment. Please note that to test it, you should have a working Kubernetes cluster. main.tf provider \"kubernetes\" { config_path = \"~/.kube/config\" } resource \"kubernetes_deployment\" \"nginx_deployment\" { metadata { name = \"nginx\" labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } spec { replicas = 1 selector { match_labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } template { metadata { labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } spec { container { name = \"nginx\" image = \"nginx:latest\" port { container_port = 80 } } } } } } Now, it's time to implement your Policy as Code to enforce some rules. With the following code, these policies will be applied to the nginx_deployment resource: The resource should have the namespace argument, and its value should be anything except default to avoid running the resource in the default namespace. The resource should have the app.kubernetes.io/env label, and its value should be development or production to pass this policy rule. The resource should have at least 2 replicas. Due to the use of the ignore_errors argument, it's an optional rule and can be ignored by the engine. The resource should have the image argument with a specific Nginx version and cannot use the latest tag of the docker image. tests.py from tf2 import Tf2 , Terraform , TerraformPlanLoader tf2 = Tf2 ( Terraform ( TerraformPlanLoader ())) @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_namespace_not_default ( self ): assert self . values . metadata [ 0 ] . namespace != \"default\" @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_label_env ( self ): assert ( self . values . metadata [ 0 ] . labels . app_kubernetes_io_env in [ \"production\" , \"development\" ]) is True assert ( self . values . spec [ 0 ] . template [ 0 ] . metadata [ 0 ] . labels . app_kubernetes_io_env in [ \"production\" , \"development\" ]) is True @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" , ignore_errors = True ) def test_nginx_min_replicas ( self ): assert int ( self . values . spec [ 0 ] . replicas ) >= 2 @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_image_not_latest ( self ): assert self . values . spec [ 0 ] . template [ 0 ] . spec [ 0 ] . container [ 0 ] . image . count ( \":\" ) == 1 assert self . values . spec [ 0 ] . template [ 0 ] . spec [ 0 ] . container [ 0 ] . image . endswith ( \":latest\" ) is False tf2 . run () Now, create the Terraform plan file: terraform init terraform plan -out terraform.tfplan Saved the plan to: terraform.tfplan ls main.tf providers.tf terraform.tfplan tests.py Important If you use any CI / CD systems to automate your Terraform pipelines, save the terraform.tfplan file as an artifact of the pipeline. In the case of any errors, you can investigate them by using this file. It's time to put everything together and run the test. Before running tests, make sure you have installed the tf2project package. Run pip install tf2project to install it. Run your TF2 tests with the following command: python tests.py The test failed because the Terraform code does not follow our policies. Now, update the Terraform code to the following code to follow the policies, recreate the Terraform plan and run tests.py again to see the result. main.tf provider \"kubernetes\" { config_path = \"~/.kube/config\" } resource \"kubernetes_deployment\" \"nginx_deployment\" { metadata { name = \"nginx\" namespace = \"test\" labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } spec { replicas = 3 selector { match_labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } template { metadata { labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } spec { container { name = \"nginx\" image = \"nginx:1\" port { container_port = 80 } } } } } } Create the Terraform plan file: terraform plan -out terraform.tfplan Run TF2 tests with the following command: python tests.py Result If tests pass, the test script will be exited with return code 0 , and passed will be written to the .tf2result file, and if they fail, the test script will be exited with return code 1 , and failed will be written to the .tf2result file. That's it. You wrote your first Policy as Code with Terraform Test Framework. Now, you can deliver more reliable and secure Terraform codes.","title":"Policy as Code"},{"location":"docs/getting-started/policy-as-code.html#getting-started-policy-as-code","text":"Policy as Code, PaC , is a set of rules and conditions which is written as a code. With Policy-as-Code, you can implement compliance tests and enforce developers to write their codes in a standard way which fits your company rules. In the case of Terraform: DevOps engineers write Terraform codes. You write Policy-as-Code codes. When DevOps engineers make any changes in repositories containing Terraform codes, the PaC codes will be run as part of CI pipelines. If they have not followed PaC rules, the pipeline fails, and changes are not accepted to be merged into the main branch. I'm compatible TF2 is fully compatible with Jenkins CI , Gitlab CI , GitHub Actions and Azure Pipelines.","title":"Getting Started: Policy as Code"},{"location":"docs/getting-started/policy-as-code.html#your-first-policy-as-code","text":"Consider the following Terraform code. This is a standard Terraform code which is written by DevOps engineers to deploy a Deployment Resource in a Kubernetes environment. Please note that to test it, you should have a working Kubernetes cluster. main.tf provider \"kubernetes\" { config_path = \"~/.kube/config\" } resource \"kubernetes_deployment\" \"nginx_deployment\" { metadata { name = \"nginx\" labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } spec { replicas = 1 selector { match_labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } template { metadata { labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" } } spec { container { name = \"nginx\" image = \"nginx:latest\" port { container_port = 80 } } } } } } Now, it's time to implement your Policy as Code to enforce some rules. With the following code, these policies will be applied to the nginx_deployment resource: The resource should have the namespace argument, and its value should be anything except default to avoid running the resource in the default namespace. The resource should have the app.kubernetes.io/env label, and its value should be development or production to pass this policy rule. The resource should have at least 2 replicas. Due to the use of the ignore_errors argument, it's an optional rule and can be ignored by the engine. The resource should have the image argument with a specific Nginx version and cannot use the latest tag of the docker image. tests.py from tf2 import Tf2 , Terraform , TerraformPlanLoader tf2 = Tf2 ( Terraform ( TerraformPlanLoader ())) @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_namespace_not_default ( self ): assert self . values . metadata [ 0 ] . namespace != \"default\" @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_label_env ( self ): assert ( self . values . metadata [ 0 ] . labels . app_kubernetes_io_env in [ \"production\" , \"development\" ]) is True assert ( self . values . spec [ 0 ] . template [ 0 ] . metadata [ 0 ] . labels . app_kubernetes_io_env in [ \"production\" , \"development\" ]) is True @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" , ignore_errors = True ) def test_nginx_min_replicas ( self ): assert int ( self . values . spec [ 0 ] . replicas ) >= 2 @tf2 . test ( \"resources.kubernetes_deployment.nginx_deployment\" ) def test_nginx_image_not_latest ( self ): assert self . values . spec [ 0 ] . template [ 0 ] . spec [ 0 ] . container [ 0 ] . image . count ( \":\" ) == 1 assert self . values . spec [ 0 ] . template [ 0 ] . spec [ 0 ] . container [ 0 ] . image . endswith ( \":latest\" ) is False tf2 . run () Now, create the Terraform plan file: terraform init terraform plan -out terraform.tfplan Saved the plan to: terraform.tfplan ls main.tf providers.tf terraform.tfplan tests.py Important If you use any CI / CD systems to automate your Terraform pipelines, save the terraform.tfplan file as an artifact of the pipeline. In the case of any errors, you can investigate them by using this file. It's time to put everything together and run the test. Before running tests, make sure you have installed the tf2project package. Run pip install tf2project to install it. Run your TF2 tests with the following command: python tests.py The test failed because the Terraform code does not follow our policies. Now, update the Terraform code to the following code to follow the policies, recreate the Terraform plan and run tests.py again to see the result. main.tf provider \"kubernetes\" { config_path = \"~/.kube/config\" } resource \"kubernetes_deployment\" \"nginx_deployment\" { metadata { name = \"nginx\" namespace = \"test\" labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } spec { replicas = 3 selector { match_labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } template { metadata { labels = { \"app.kubernetes.io/name\" = \"nginx\" \"app.kubernetes.io/created-by\" = \"tf2project\" \"app.kubernetes.io/env\" = \"development\" } } spec { container { name = \"nginx\" image = \"nginx:1\" port { container_port = 80 } } } } } } Create the Terraform plan file: terraform plan -out terraform.tfplan Run TF2 tests with the following command: python tests.py Result If tests pass, the test script will be exited with return code 0 , and passed will be written to the .tf2result file, and if they fail, the test script will be exited with return code 1 , and failed will be written to the .tf2result file. That's it. You wrote your first Policy as Code with Terraform Test Framework. Now, you can deliver more reliable and secure Terraform codes.","title":"Your first Policy as Code"}]}